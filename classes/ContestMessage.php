<?php
class ContestMessage {
	protected $timestamp; // autogenerated upon instantiation
	protected $team;
	
	const VERSION = '1.0-dev';

	public function __construct($data = null) {
		if ($data != null && !is_object($data)) {
			throw new ContestException('object expected', 500);
		}

		if (isset($data->version) && $data->version != self::VERSION) {
			throw new ContestException('version mismatch', 400);
		}

		$this->timestamp = microtime(true);
	}

	public function __toString() {
		return print_r(get_object_vars($this), true);
	}

	public function __toJSON() {
		return plista_json_encode("$this");
	}

	/**
	 * returns a mapping of the msg-property in the received json to the appropriate class this handler supports.
	 * @param $msg string the name of the message
	 * @return ContestMessage an instance of ContestMessage representing the requested message
	 * @throws ContestException if no appropriate ContestMessage type is known
	 */
	public static function createMessage($msg, $data = null) {
		switch ($msg) {
			case 'impression':
			case 'feedback':
			case 'result':
				$classname = 'Contest' . ucfirst($msg);
				return new $classname($data);
			case 'processing':
				return new ContestResponseImpression($data);
			case 'thanks':
				return new ContestResponseFeedback($data);
			default:
				throw new ContestException("unknown message type", 400);
		}
	}

	public static function createError($data) {
		if (!is_object($data)) {
			$obj = new stdClass;
			$obj->error = $data;
			$data = $obj;
		}

		return new ContestError($data);
	}

	/**
	 * static function to create a new instance of a ContestMessage directly from JSON input
	 *
	 * @param string $json
	 * @return ContestMessage
	 */
	public static function fromJSON($json) {
		if (empty($json)) {
			throw new ContestException("message may not be empty", 400);
		}

		// decode JSON
		$json_obj = json_decode($json);

		if ($json_obj == null) {
			throw new ContestException("parsing json failed", 400);
		}

		// look at type and return appropriate class
		if (isset($json_obj->msg)) {
			//return static::createMessage($json_obj->msg, $json_obj);
			return self::createMessage($json_obj->msg, $json_obj);
		} else if (isset($json_obj->error)) {
			//return static::createError($json_obj);
			return self::createError($json_obj);
		} else {
			throw new ContestException("message syntax error", 400);
		}
	}

	/**
	 * Returns an appropriate response object for this message. Quasi abstract.
	 * @return ContestMessage $message
	 */
	public function getResponse() {
		return null;
	}

	public function postTo($target, $fetch_response = true, $callback = null) {
		if ($target == 'stdout') {
			if (!headers_sent()) {
				header('Content-Type: application/json');
			}

			echo plista_json_encode($this) . PHP_EOL;
			flush();
		} else {
			// create new HttpRequest
			$request = new HttpRequest($target, $callback);

			// post this message and return the result (which may be null)
			return $request->post($this, $fetch_response);
		}
	}
	
	public function __get($name) {
		if (!isset($this->$name)) {
			return null;
		}

		return $this->$name;
	}
}
